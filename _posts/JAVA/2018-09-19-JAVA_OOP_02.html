---
layout: post
title: "OOP_02_변수와 메서드"
subtitle:
date: 2018-09-19
author: RDcastle
category: JAVA
finished: true
---

<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="D:\Openproject\rdcastle.github.io\css\font-awesome\css\custom.css">
</head>

<body>
  <article>
    <ol>
      <li>
        <h1>선언위치에 따른 변수의 종류</h1>
        <p>
          <h3>멤버변수와 지역변수</h3>
          <p>
            클래스 내에서 멤버변수는 전역적 개념이고, 지역변수는 메서드(함수) 내부에서만 사용되고 사라지는 변수이다. 멤버변수를 제외하면 지역변수라고 보면 된다
          </p>
          <h3>클래스 변수와 인스턴스 변수</h3>
          <p>
            클래스를 기반으로 만든 객체를 인스턴스라고 한다. 멤버변수 중에서 인스턴스에 포함되어 생성되는 변수를 인스턴스 변수라 하고(인스턴스 별로 독립적인 저장공간을 갖고 생성됨),
            인스턴스에 포함되어 생성되지 않으면서 클래스에 고정적으로 정의되어 있는 전역적 변수를 클래스 변수라고 한다. 추상적으로 존재하는 클래스의 차원에서 모든 인스턴스들이
            공통적으로 참조할 수 있도록 정의된다. 정의 시 static 키워드를 추가하는 것도 변함 없이 모든 인스턴스에서 참조하기 위함이다. 또한, 클래스 변수는 public 제어자로 설정되면 별도로 선언하지 않고도
            '클래스명.클래스변수' 방식으로 참조해서 사용할 수 있다.<br>클래스는 일종의 설계도로 추상적인 개념이지만, 클래스변수는 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때까지 유지된다.
          </p>
        </p>
      </li>
      <li>
        <h1>메서드를 사용하는 이유</h1>
        <p>
          method 는 특정 작업을 수행하는 일련의 문장들을(명령) 하나로 묶은 것이다. 기본적으로 함수와 유사하며, 기능 중심적이므로 내부적인 로직은 몰라도 된다(블랙박스)
          <ul>
            <li>reusability: 높은 재사용성!</li>
            <li>중복된 코드의 제거: 중복을 제거하는 것은 간결하면서도 기하급수적인 효율을 발생시킬 수 있다</li>
            <li>프로그램의 구조화: 대규모 코딩에서는 작업단위별로 분류하여 알아보기 쉽고 단순한 구조로 프로그래밍할 수 있다</li>
          </ul>
        </p>
      </li>
      <li>
        <h1>매개변수의 유효성 검사</h1>
        <p>
          메서드의 구현부 {} 를 작성할 때, 제일 먼저 해야 하는 일이 매개변수의 값이 적절한 것인지 확인하는 것이다. 메서드를 작성하는 사람은 '호출하는 쪽에서 알아서 적절한 값을 넘겨주겠지'라는
          생각을 절대로 가져서는 안 된다. 타입만 맞으면 어떤 값도 매개변수를 통해 넘어올 수 있기 때문에, 가능한 모든 경우의 수에 대해 고민하고 그에 대비한 코드를 작성해야 한다(나누기 메서드에서 0으로 나누는 것 필터링)
        </p>
      </li>
      <li>
        <h1>JVM 의 메모리 구조</h1>
        <p>
          JAVA 응용프로그램이 실행되면 JVM 은 시스템으로부터 메모리를 할당받고, 용도에 따라 여러 영역으로 나누어 관리한다
          <h3>3가지 주요 영역</h3>
          <ul>
            <li><span class="emp">method area</span>: 프로그램 실행 중에 JVM 은 필요한 클래스파일을 읽어 분석하여 해당 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이때 클래스 변수도 생성된다</li>
            <li><span class="emp">heap</span>: 프로그램 실행 중에 만들어지는 모든 인스턴스가 생성되는 공간이다. 인스턴스 변수도 생성</li>
            <li><span class="emp">call stack(execution stack)</span>: 호출 스택, 직접적인 작업공간으로써 메서드의 작업에 필요한 메모리 공간을 제공한다. 작업 수행 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다. 메서드 작업이 종료되면
            이곳에 할당되었던 메모리 공간은 반환되어 비워지며, 대표적으로 main 메서드가 있다. 메서드 실행 중에 또다른 메서드를 호출하면, 스택(stack) 방식으로 메모리에 축적된다(FILO, 최상위층이 현재 실행 메서드). 반환 타입이 있다면 값을 반환하고
            해당 메서드를 호출했던 바로 이전 메서드(caller)는 그 값으로 작업을 이어간다</li>
          </ul>
        </p>
      </li>
      <li>
        <h1>기본형 매개변수와 참조형 매개변수, 참조형 반환타입</h1>
        <p>
          메서드가 호출되면서 넘겨받는 변수를 매개변수라 한다. 특정 객체에 대하여 단순히 값만 복사하여 넘겨받으면 기본형 매개변수, 개체 자체의 주소값을 넘겨받으면 참조형 매개변수이다(CPP의 레퍼런스와 유사한 개념). 참조형 매개변수를 넘겨받아 값을 변경하면
          본래 저장된 값이 바뀌지만, 기본형 매개변수는 그렇지 않다. 또한, 배열도 참조 방식으로 데이터에 접근하기 때문에 클래스 객체 대신 매개변수로 참조 가능하다
        </p>
        <p>
          참조형 반환타입이란, 클래스 객체나 배열과 같이 특정 데이터공간의 주소값을 반환하는 것을 지칭한다. 클래스도 일종의 자료형이므로, 반환 데이터타입을 클래스(사용자지정 타입)로 정의할 수 있다
        </p>
      </li>
      <li>
        <h1>클래스 메서드(static method)와 인스턴스 메서드</h1>
        <p>
          이 관계는 클래스 변수와 인스턴스 변수 간의 관계와 유사하며, 요약하자면 다음과 같다
          <ul>
            <li>클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static 을 붙안다</li>
            <li>클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용 가능하다</li>
            <li>클래서 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다</li>
            <p> 클래스 변수가 호출된 시점에 인스턴스가 생성되어 있지 않을 수도 있으므로 원천적으로 금지한다. 그 역은 가능하다</p>
            <li>메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다</li>
            <p> 메서드 내에서 인스턴스가 필요한 것이 아니라면, static 으로 정의해(클래스 메서드) 별도의 인스턴스 생성 없이도 메서드 호출이 가능하도록 하여 호출 시간 및 성능이 향상되도록 하는 것이 좋다</p>
            <li>멤버변수 중에서도 모든 인스턴스에 공통된 값을 유지해야 하는 것이 있다면 static 을 붙여준다</li>
            <li> ex) Math 클래스의 random() 메서드. Math 클래스는 모든 작업을 넘겨받은 매개변수를 클래스화 하여 수행하므로 인스턴스 변수가 필요 없다</li>
          </ul>
        </p>
      </li>
      <li>
        <h1>클래스 멤버와 인스턴스 멤버간의 참조와 호출</h1>
        <p>
          같은 클래스 멤버라면 별도의 인스턴스 생성 없이 언제든 참조 가능하지만, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다(인스턴스 멤버는 인스턴스 멤버를 참조해도 에러 나지 않음. 그 이유는 생각해볼 것)
        </p>
      </li>
    </ol>
  </article>
</body>

</html>
