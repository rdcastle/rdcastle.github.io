---
layout: post
title: "OOP_03_상속"
subtitle:
date: 2018-10-01
author: RDcastle
category: JAVA
finished: true
---

<html>

<head>
  <meta charset="utf-8">
  <style>
    @import url(https://fonts.googleapis.com/css?family=Nanum+Gothic|Nanum+Myeongjo);
    @import url('https://fonts.googleapis.com/css?family=Jua|Nanum+Gothic|Nanum+Myeongjo');
    @import url(https://fonts.googleapis.com/earlyaccess/hanna.css);

    * {
      font-family: 'Nanum Gothic', sans-serif;
      font-family: 'Nanum Myeongjo', serif;
      font-family: 'Jua', sans-serif;
    }

    h1 {
      font-family: 'Hanna';
    }

    h3 {
      color: Orchid;
    }

    .emp {
      color: red;
      font-style: italic;
    }

    pre {
      background-color: #F5F5DC;
      color: black;
      font-weight: bold;
    }
  </style>
</head>

<body>
  <article>
    <ol>
      <li>
        <h1>상속</h1>
        <p>상속은 부모클래스의 전체 내용을 자식 클래스가 물려받는 일종의 '확장' 개념이다. 결과적으로 적은 양의 코드로 새로운 클래스를 작성할 수 있으며 중복이 제거되고 코드 재사용성이 높아진다.</p>
        <p>
          상속은 'extends' 키워드로 명시한다. 형식은 다음과 같다
          <pre>
            class [자식클래스명] extends [부모클래스명] {
              // 코드 내용
            }
          </pre>
        </p>
      </li>
      <li>
        <h1>상속 정리</h1>
        <p>
          <ul>
            <li>생성자와 초기화블럭은 상속되지 않는다. 멤버만 상속된다: 자식클래스를 인스턴스화하면 부모클래스의 생성자와 초기화블럭이 가장 먼저 호출되기 때문. 자식클래스의 생성자를 별도로 정의했다면 그 다음으로 호출된다</li>
            <li>자식클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다: 이는 상속이 기존 것에서 새로운 것을 추가해 나가는 '확장' 개념이기 때문이다</li>
            <li>포함관계와 상속관계: 코드가 복잡해짐에 따라 각 클래스 간의 관계를 분명히 설계해야 오류를 줄이고 효율적인 재사용성이 높아진다. <strong>포함관계</strong>는 상속이 아닌 참조로 이루어진 동등한 관계이고(필요한 부분을 참조), <strong>상속관계</strong>는 부모클래스의
              멤버들을 물려받아 확장하는 상하의 관게이다</li>
            <li>관계 결정하기: <strong>'is-a'</strong> 관계는 상속관계, <strong>'has-a'</strong> 관계는 포함관계이다. 이에 따라 관계를 한 문장으로 기술하고 논리적 모순성을 검증함으로써 관계를 명백히 규정할 수 있다</li>
            <li>단일상속과 다중상속: CPP 에서는 다중상속까지 허용하지만 JAVA 에서는 허용하지 않는다. 현실적으로 다중상속은 클래스 간의 관계를 매우 복잡하게 만들어 중복되는 멤버가 존재하거나 순환의존관계에 빠지게 만드는 등 위험성이 크다.
              보다 발전한 객체지향언어로써의 JAVA 는 이러한 위험성 때문에 다중상속을 원천적으로 금지했다(다중상속을 하다보면 정체를 알 수 없는 monster 가 튀어나오기 십상이다)</li>
            <li>Object 클래스: 최상위 부모클래스로 모든 인스턴스(사용자가 만든 객체까지도)의 조상이다. 이것은 상속의 의미로 extends Object 명시할 필요가 없으며, toString() 이나 equals(Object o) 와 같은 기본적인 메서드들을 별도의 import 없이 사용한 것처럼 보이는 이유도
             모든 객체가 Object 클래스로부터 비롯되기 때문이다</li>
            <li>super 키워드 01: 한 클래스에서 this 키워드로 클래스멤버와 인스턴스 및 지역멤버를 구분했듯이, 상속 관계에서 조상의 멤버와 자식의 멤버를 구분하는데 사용하는 키워드가 <strong>super</strong> 이다. 만약 같은 이름의 멤버변수 x 가 조상클래스와 자식클래스에 각각 존재할 때
             자식클래스 입장에서 <strong>this.x</strong> 는 자신이 소유한 멤버변수 x 를, <strong>super.x</strong> 는 조상이 소유한 멤버변수 x 를 의미한다</li>
            <li>super 키워드 02: 이러한 규칙은 메서드에도 동일하게 적용된다. 자식클래스에서 오버라이딩 시 동일한 이름의 부모클래스 메서드를 super.[클래스명()] 형태로 호출하여 활용할 수 있다. 또한 this() 와 마찬가지로 super() 메서드는 부모 클래스의 생성자로써 조상클래스의
             멤버변수를 자식클래스에서 초기화할 시, super() 메서드를 활용하여 초기화해야만 한다(<strong>super.x = 5;</strong> 이런 식으로 초기화하지 말고 <strong>super(5);</strong> 해야 함)</li>
          </ul>
        </p>
      </li>
    </ol>
  </article>
</body>

</html>
