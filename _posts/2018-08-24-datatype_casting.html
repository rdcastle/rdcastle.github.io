---
layout: post
title: "자료형 형변환"
subtitle:
date: 2018-08-24
author: RDcastle
category: C
finished: true
---
<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
  </head>
  <body>
    <h1>자동 형변환(묵시적 형변환)</h1>
    <p>말 그대로 특정 자료형의 변수에 다른 자료형의 데이터를 대입할 때, 좌항 변수의 자료형을 기준으로 대입 데이터가
    자동으로 형변환되는 것을 의미한다.</p>
    <ul>
      <li>double num = 245;</li>
      <li>int 형 245가 double 로 형변화되어 245.0 으로 대입됨.</li>
    </ul>
    <p>이때, 기준 변수의 크기에 포괄되는 사이즈의 자료형이 대입되면 문제 발생의 여지가 적겠지만,
    그렇지 않은 경우 데이터 손실이 발생할 수도 있다(컴파일은 되지만 경고메시지 출력됨).</p>
    <ul>
      <li>int num1 = 3.1415;</li>
      <li>위의 경우에서 별도의 명시가 없다면 좌항은 int 형, 우항은 double 형이다</li>
      <li>실수형의 사이즈가 더 크므로 손실이 발생할 수 있다는 경고메시지 출력됨</li>
      <li>실제 대입시 정수형으로 변환된다 > 소수점 이하 모든 데이터는 손실</li>
      <li>이러한 묵시적 형변환은 필요에 따라 나눗셈의 몫을 구하는 방법으로 쓰임</li>
    </ul>

    <h3>정수의 승격</h3>
    <p>
      CPU 연산 시 최적의 자료형은 'int' 이다. 예를 들어 short 형 변수(2Byte)가 연산될 때는 임시적으로 int 형으로 형변환 되었다가(결과도 int 형)
      결과값이 저장되는 시점에서 다시 short 형으로 저장된다. 이때 연산을 위해 short 형이 int 형으로 변환되는 과정을 '<strong>정수의 승격</strong>'이라고 한다
    </p>
    <p>
      그렇다면, int 형보다 사이즈가 큰 경우는?<br>테스트 결과, long long 의 경우 int로 변환되지 않는 것을 확인(8byte 그대로).
      실수끼리의 연산시에도 정수의 승격은 일어나지 않음<br>현재 CPU 성능이 좋아져서 연산과 관련한 이러한 차이가 거의 사라지기는 했지만,
      원리적인 측면에서 아직 의미가 있음
    </p>

    <h1>강제 형변환(명시적 형변환)</h1>
    <p>자동 형변환은 대입시 사이즈에 따라 묵시적인 변화가 일어난 반면, 강제 형변환은 변환할 자료형을 명시적으로
    지정한다.</p>
    <ul>
      <li>int num1 = 3, num2 = 4;</li>
      <li>  double num3 = num1 / num2</li>
      <li>  >>> num3 = 0.000000</li>
    </ul>
    <ul>
      <li>int num1 = 3, num2 = 4;</li>
      <li>  double num3 = (double) num1 / num2;</li>
      <li>  >>> num3 = 0.750000</li>
    </ul>
    <p>위의 경우 int 형인 num1, num2 가 먼저 계산되어 0이 되므로 그것을 암시적으로 형변환 해도 0.000000 이 된다. 그러나 아래의 경우
    연산 수행 전에 int 형을 double 형으로 강제 형변환한 후 연산을 수행했으므로, 소수점 이하 자리까지 유의미한 결과가 나온다
    (나눗셈의 한쪽 항만 실수형이면 결과도 실수형이 나옴. 데이터손실이 적은 방향으로 연산하기 때문 > 데이터손실 최소화 규칙).</p>
    <p>어차피 결과값이 동일할 경우, 추후 코드분석을 위해 명시적으로 표시해주는 것이 좋다.(+ 주석처리)</p>

    <h3>피연산자의 자료형이 불일치하는 경우 자동 형 변환</h3>
    <p>데이터손실 관점에서의 우선순위<br>
		: int < long < long long < float < double < long double<br>
    이를 참고하면, 우선순위의 기준은 1. 정수 < 실수 2. 데이터 사이즈 로 압축 가능하다.<br>
		또한 char, short형의 경우는 어차피 연산시 int형으로 변환되기 때문에 고려할 필요가 없다</p>
  </body>
</html>
